(ns day6
  (:require  [clojure.java.io :as io]
             [clojure.string  :as str]))

;; Naive implementation for part1, memory hungry
(defn- tick
  [value]
  (if (zero? value) [6 8] [(dec value)]))

(defn- input
  [path]
  (-> (io/resource path)
      (slurp)
      (str/trim)
      (str/split #",")
      (->> (mapv #(Long/parseLong %)))))

(defn- count-fishes
  [days init-fishes]
  (loop [[x & xs] (range days)
         fishes   init-fishes]
    (if (nil? x)
      (count fishes)
      (recur xs (mapcat tick fishes)))))

;; For part2 a different approach: we keep a track of known generated fish
;; counts for each fish. Each fish is represented as a tuple of current
;; tick value and remaining days

(defn- can-generate?
  [[v remaining]]
  (> remaining v))

(defn- generations
  "fishes generated by one fish"
  [[init days]]
  (when (can-generate? [init days])
    (let [shift    (- 6 init)
          days     (+ days shift)
          num-gens (quot days 7)
          shift    (rem days 7)]
      (for [x (range num-gens)] [8 (+ shift (* x 7))]))))

(def ^:private count-fish
  (memoize
   (fn [fish]
     (let [gens (generations fish)
           subs (into [] (filter can-generate?) gens)]
       (reduce + (count gens) (map count-fish subs))))))

(defn- count-fishes-fast
  [days fishes]
  (->> fishes
       (map (fn [x] [x days]))
       (map count-fish)
       (reduce + (count fishes))))

(defn part1 [path] (count-fishes 80 (input path)))
(defn part2 [path] (count-fishes-fast 256 (input path)))

(comment
  (part1 "input6.txt")
  (part2 "input6.txt")
  )
